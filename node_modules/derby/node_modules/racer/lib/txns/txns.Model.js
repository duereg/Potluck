// Generated by CoffeeScript 1.3.3
var Memory, Promise, RESEND_INTERVAL, SEND_TIMEOUT, Serializer, arrayMutator, createMiddleware, isPrivate, mergeTxn, specCreate, transaction,
  __slice = [].slice;

Memory = require('../Memory');

Promise = require('../util/Promise');

Serializer = require('../Serializer');

transaction = require('../transaction');

isPrivate = require('../path').isPrivate;

specCreate = require('../util/speculative').create;

mergeTxn = require('./diff').mergeTxn;

createMiddleware = require('../middleware');

arrayMutator = null;

module.exports = {
  type: 'Model',
  "static": {
    SEND_TIMEOUT: SEND_TIMEOUT = 10000,
    RESEND_INTERVAL: RESEND_INTERVAL = 2000
  },
  events: {
    mixin: function(Model) {
      return arrayMutator = Model.arrayMutator, Model;
    },
    init: function(model) {
      var bundlePromises, memory, specCache, txnQueue, txns;
      if (bundlePromises = model._bundlePromises) {
        bundlePromises.push(model._txnsPromise = new Promise);
      }
      model._specCache = specCache = {
        invalidate: function() {
          delete this.data;
          return delete this.lastTxnId;
        }
      };
      model._count.txn = 0;
      model._txns = txns = {};
      model._txnQueue = txnQueue = [];
      model._removeTxn = function(txnId) {
        var i;
        delete txns[txnId];
        if (~(i = txnQueue.indexOf(txnId))) {
          txnQueue.splice(i, 1);
          specCache.invalidate();
        }
      };
      memory = model._memory;
      return model._onTxn = function(txn) {
        var isLocal, txnQ, ver;
        if (txn == null) {
          return;
        }
        if (txnQ = txns[transaction.getId(txn)]) {
          txn.callback = txnQ.callback;
          txn.emitted = txnQ.emitted;
        }
        isLocal = 'callback' in txn;
        ver = transaction.getVer(txn);
        if (ver > memory.version || ver === -1) {
          model._applyTxn(txn, isLocal);
        }
      };
    },
    middleware: function(_model, middleware) {
      middleware.txn = createMiddleware();
      middleware.txn.add(function(req, res, next) {
        var args, arr, method, model, path, txn;
        txn = req.data;
        method = transaction.getMethod(txn);
        args = transaction.getArgs(txn);
        model = req.model;
        model.emit('beforeTxn', method, args);
        if ((path = args[0]) == null) {
          return;
        }
        txn.isPrivate = isPrivate(path);
        args = transaction.getArgs(txn);
        txn.emitted = args.cancelEmit;
        if (method === 'pop') {
          txn.push((arr = model.get(path) || null) && (arr.length - 1));
        } else if (method === 'unshift') {
          txn.push((model.get(path) || null) && 0);
        }
        return next();
      });
      middleware.txn.add(function(req, res, next) {
        var id, model, txn;
        txn = req.data;
        model = req.model;
        id = transaction.getId(txn);
        model._txns[id] = txn;
        model._txnQueue.push(id);
        return next();
      });
      middleware.txn.add(function(req, res, next) {
        var model;
        model = req.model;
        res.out = model._specModel().$out;
        return next();
      });
      middleware.txn.add(function(req, res, next) {
        var args, method, model, out, txn;
        txn = req.data;
        args = transaction.getArgs(txn);
        method = transaction.getMethod(txn);
        if (method === 'push') {
          out = res.out;
          transaction.setMeta(out - args.length + 1);
          txn.push(out - args.length + 1);
        }
        model = req.model;
        model._commit(txn);
        return next();
      });
      return middleware.txn.add(function(req, res, next) {
        var args, method, model, out, txn;
        out = res.out;
        txn = req.data;
        if (!txn.emitted) {
          method = transaction.getMethod(txn);
          args = transaction.copyArgs(txn);
          model = req.model;
          model.emit(method, args, out, true, model._pass);
          txn.emitted = true;
        }
        return out;
      });
    },
    bundle: function(model) {
      model._txnsPromise.on(function(err) {
        var clientId, store;
        if (err) {
          throw err;
        }
        clientId = model._clientId;
        if (store = model.store) {
          store._unregisterLocalModel(clientId);
        } else {
          console.warn("ALREADY UNREGISTERED SERVER MODEL");
          console.trace();
        }
        return store._startTxnBuffer(clientId);
      });
      model._specModel();
      if (model._txnQueue.length) {
        model.__removeTxn__ || (model.__removeTxn__ = model._removeTxn);
        model._removeTxn = function(txnId) {
          var len;
          model.__removeTxn__(txnId);
          len = model._txnQueue.length;
          model._specModel();
          if (len) {
            return;
          }
          return process.nextTick(function() {
            return model._txnsPromise.resolve();
          });
        };
        return;
      }
      return model._txnsPromise.resolve();
    },
    socket: function(model, socket) {
      var addRemoteTxn, commit, memory, onTxn, removeTxn, resend, resendInterval, setupResendInterval, teardownResendInterval, txnApplier, txnQueue, txns;
      memory = model._memory, txns = model._txns, txnQueue = model._txnQueue, removeTxn = model._removeTxn, onTxn = model._onTxn;
      socket.on('snapshotUpdate:replace', function(data, num) {
        var toReplay, txn, txnId, _i, _len;
        toReplay = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = txnQueue.length; _i < _len; _i++) {
            txnId = txnQueue[_i];
            _results.push(txns[txnId]);
          }
          return _results;
        })();
        txnQueue.length = 0;
        model._txns = txns = {};
        model._specCache.invalidate();
        txnApplier.clearPending();
        if (num != null) {
          txnApplier.setIndex(num + 1);
        }
        memory.eraseNonPrivate();
        model._addData(data);
        model.emit('reInit');
        for (_i = 0, _len = toReplay.length; _i < _len; _i++) {
          txn = toReplay[_i];
          model[transaction.getMethod(txn)].apply(model, transaction.getArgs(txn));
        }
      });
      socket.on('snapshotUpdate:newTxns', function(newTxns, num) {
        var id, txn, _i, _j, _len, _len1;
        for (_i = 0, _len = newTxns.length; _i < _len; _i++) {
          txn = newTxns[_i];
          onTxn(txn);
        }
        txnApplier.clearPending();
        if (num != null) {
          txnApplier.setIndex(num + 1);
        }
        for (_j = 0, _len1 = txnQueue.length; _j < _len1; _j++) {
          id = txnQueue[_j];
          commit(txns[id]);
        }
      });
      txnApplier = new Serializer({
        withEach: onTxn,
        onTimeout: function() {
          if (!model.connected) {
            return;
          }
          return socket.emit('fetch:snapshot', memory.version + 1, model._startId, model._subs());
        }
      });
      resendInterval = null;
      resend = function() {
        var id, now, txn, _i, _len;
        now = +(new Date);
        model._specModel();
        for (_i = 0, _len = txnQueue.length; _i < _len; _i++) {
          id = txnQueue[_i];
          txn = txns[id];
          if (!txn || txn.timeout > now) {
            return;
          }
          commit(txn);
        }
      };
      setupResendInterval = function() {
        return resendInterval || (resendInterval = setInterval(resend, RESEND_INTERVAL));
      };
      teardownResendInterval = function() {
        if (resendInterval) {
          clearInterval(resendInterval);
        }
        return resendInterval = null;
      };
      if (model.connected) {
        setupResendInterval();
      } else {
        model.once('connect', function() {
          return setupResendInterval();
        });
      }
      socket.on('disconnect', function() {
        return teardownResendInterval();
      });
      model._addRemoteTxn = addRemoteTxn = function(txn, num) {
        if (num != null) {
          return txnApplier.add(txn, num);
        } else {
          return onTxn(txn);
        }
      };
      socket.on('txn', addRemoteTxn);
      socket.on('txnOk', function(rcvTxn, num) {
        var txn, txnId, ver;
        txnId = transaction.getId(rcvTxn);
        if (!(txn = txns[txnId])) {
          return;
        }
        ver = transaction.getVer(rcvTxn);
        transaction.setVer(txn, ver);
        return addRemoteTxn(txn, num);
      });
      socket.on('txnErr', function(err, txnId) {
        var callback, callbackArgs, txn;
        txn = txns[txnId];
        if (txn && (callback = txn.callback)) {
          if (transaction.isCompound(txn)) {
            callbackArgs = transaction.ops(txn);
          } else {
            callbackArgs = transaction.copyArgs(txn);
          }
          callbackArgs.unshift(err);
        }
        removeTxn(txnId);
        if (callback) {
          return callback.apply(null, callbackArgs);
        }
      });
      return model._commit = commit = function(txn) {
        if (txn.isPrivate) {
          return;
        }
        txn.timeout = +(new Date) + SEND_TIMEOUT;
        if (!model.connected) {
          return;
        }
        return socket.emit('txn', txn, model._startId);
      };
    }
  },
  server: {
    _commit: function(txn) {
      var req, res,
        _this = this;
      if (txn.isPrivate) {
        return;
      }
      req = {
        data: txn,
        ignoreStartId: true,
        clientId: this._clientId,
        session: this.session
      };
      res = {
        fail: function(err, txn) {
          _this._removeTxn(transaction.getId(txn));
          return txn.callback(err, txn);
        },
        send: function(txn) {
          return _this._onTxn(txn);
        }
      };
      return this.store.middleware.txn(req, res);
    }
  },
  proto: {
    force: function() {
      return Object.create(this, {
        _force: {
          value: true
        }
      });
    },
    _commit: function() {},
    _asyncCommit: function(txn, callback) {
      var id;
      if (!this.connected) {
        return callback('disconnected');
      }
      txn.callback = callback;
      id = transaction.getId(txn);
      this._txns[id] = txn;
      return this._commit(txn);
    },
    _nextTxnId: function() {
      return this._clientId + '.' + this._count.txn++;
    },
    _queueTxn: function(txn, callback) {
      var id;
      txn.callback = callback;
      id = transaction.getId(txn);
      this._txns[id] = txn;
      return this._txnQueue.push(id);
    },
    _getVersion: function() {
      if (this._force) {
        return null;
      } else {
        return this._memory.version;
      }
    },
    _opToTxn: function(method, args, callback) {
      var id, txn, ver;
      ver = this._getVersion();
      id = this._nextTxnId();
      txn = transaction.create({
        ver: ver,
        id: id,
        method: method,
        args: args
      });
      txn.callback = callback;
      return txn;
    },
    _sendToMiddleware: function(method, args, callback) {
      var req, res, txn;
      txn = this._opToTxn(method, args, callback);
      req = {
        data: txn,
        model: this
      };
      res = {
        fail: function(err) {
          throw err;
        },
        send: function() {
          return console.log("TODO");
        }
      };
      return this.middleware.txn(req, res);
    },
    _applyTxn: function(txn, isLocal) {
      var callback, data, doEmit, isCompound, op, ops, out, txnId, ver, _i, _len;
      if (txnId = transaction.getId(txn)) {
        this._removeTxn(txnId);
      }
      data = this._memory._data;
      doEmit = !txn.emitted;
      ver = Math.floor(transaction.getVer(txn));
      if (isCompound = transaction.isCompound(txn)) {
        ops = transaction.ops(txn);
        for (_i = 0, _len = ops.length; _i < _len; _i++) {
          op = ops[_i];
          this._applyMutation(transaction.op, op, ver, data, doEmit, isLocal);
        }
      } else {
        out = this._applyMutation(transaction, txn, ver, data, doEmit, isLocal);
      }
      if (callback = txn.callback) {
        if (isCompound) {
          callback.apply(null, [null].concat(__slice.call(transaction.ops(txn))));
        } else {
          callback.apply(null, [null].concat(__slice.call(transaction.getArgs(txn)), [out]));
        }
      }
      return out;
    },
    _applyMutation: function(extractor, txn, ver, data, doEmit, isLocal) {
      var args, method, out, patch, _i, _len, _ref;
      out = extractor.applyTxn(txn, data, this._memory, ver);
      if (doEmit) {
        if (patch = txn.patch) {
          for (_i = 0, _len = patch.length; _i < _len; _i++) {
            _ref = patch[_i], method = _ref.method, args = _ref.args;
            this.emit(method, args, null, isLocal, this._pass);
          }
        } else {
          method = transaction.getMethod(txn);
          args = transaction.getArgs(txn);
          this.emit(method, args, out, isLocal, this._pass);
          txn.emitted = true;
        }
      }
      return out;
    },
    _specModel: function() {
      var cache, data, i, lastTxnId, len, op, ops, out, replayFrom, txn, txnQueue, txns, _i, _len;
      txns = this._txns;
      txnQueue = this._txnQueue;
      while ((txn = txns[txnQueue[0]]) && txn.isPrivate) {
        out = this._applyTxn(txn, true);
      }
      if (!(len = txnQueue.length)) {
        data = this._memory._data;
        data.$out = out;
        return data;
      }
      cache = this._specCache;
      if (lastTxnId = cache.lastTxnId) {
        if (cache.lastTxnId === txnQueue[len - 1]) {
          return cache.data;
        }
        data = cache.data;
        replayFrom = 1 + txnQueue.indexOf(cache.lastTxnId);
      } else {
        replayFrom = 0;
      }
      if (!data) {
        data = cache.data = specCreate(this._memory._data);
      }
      i = replayFrom;
      while (i < len) {
        txn = txns[txnQueue[i++]];
        if (transaction.isCompound(txn)) {
          ops = transaction.ops(txn);
          for (_i = 0, _len = ops.length; _i < _len; _i++) {
            op = ops[_i];
            this._applyMutation(transaction.op, op, null, data);
          }
        } else {
          out = this._applyMutation(transaction, txn, null, data);
        }
      }
      cache.data = data;
      cache.lastTxnId = transaction.getId(txn);
      data.$out = out;
      return data;
    }
  }
};
