var QueryHub = require('./QueryHub')
  , QueryBuilder = require('./QueryBuilder')
  , path = require('../path')
  , splitPath = path.split
  , lookup = path.lookup
  , finishAfter = require('../util/async').finishAfter
  , queryUtils = require('./util')
  , resultPointerPath = queryUtils.resultPointerPath
  , compileTargets = queryUtils.compileTargets
  , QueryMotifRegistry = require('./QueryMotifRegistry')
  , createMiddleware = require('../middleware')
  ;

module.exports = {
  type: 'Store'

, events: {
    init: function (store, opts) {
      store._queryCoordinator = new QueryHub(store);

      // Contains registered query motifs defined via store.query.expose
      var registry = store._queryMotifRegistry = new QueryMotifRegistry;

      /**
       * Exposes a parameterized data set equivalent to the result set of a
       * query generated by the `callback`. The parameterized
       * Behind the scenes, this creates a QueryMotif.
       * Query motifs define a set of data equivalent to the result set of a
       * query, and they provide an easy string name reference to this data. This
       * declares and registers a query motif that will subsequently be available
       * from the Store or Model via Store#_queryMotifRegistry and
       * Model#_queryMotifRegistry respectively.
       *
       * @optional @param {String} ns is the namespace of documents over which to
       * query
       * @param {String} motifName is the name of the query motif
       * @param {Function} callback in which we define the query.
       * callback(queryArgs...) returns a QueryBuilder
       * @return {Object} store.query for method chaining
       * @api public
       */
      store.query.expose = function (ns, motifName, callback) {
        registry.add(ns, motifName, callback);
        return store.query;
      };
    }
  , middleware: function (store, middleware) {
      var mode = store._mode;
      middleware.snapshot = createMiddleware()
      if (mode.startIdVerifier) {
        middleware.snapshot.add(mode.startIdVerifier);
      }
      middleware.snapshot.add( function (req, res, next) {
        var clientId = req.clientId;
        if (req.shouldSubscribe) {
          store._pubSub.subscribe(clientId, req.subs);
        }
        mode.snapshotSince({
          ver: req.ver
        , clientId: clientId
        , subs: req.subs
        , session: req.session
        , context: req.context
        }, function (err, payload) {
          if (err) return res.fail(err);
          var data = payload.data
            , txns = payload.txns
            , num = store._txnClock.nextTxnNum(clientId);
          if (data) {
            res.send('snapshotUpdate:replace', data, num);
          } else if (txns) {
            var len;
            if (len = txns.length) {
              socket.__ver = transaction.getVer(txns[len-1]);
            }
            res.send('snapshotUpdate:newTxns', txns, num);
          }
          next();
        });
      });

      middleware.fetch = createMiddleware()
      middleware.fetch.add(function (req, res, next) {
        var targets = req.targets
          , data = []
          , finish = finishAfter(targets.length, function (err) {
              if (err) return cb(err);
              var out = {data: data};
              store.emit('fetch', out, req.clientId, targets);
              res.send(out);
            })
          , session = req.session;
        for (var i = 0, l = targets.length; i < l; i++) {
          var target = targets[i];
          var _req = {
            target: target
          , clientId: req.clientId
          , session: req.session
          , context: req.context
          };
          var _res = {
            fail: function (err) {
              res.fail(err);
            }
          , send: function (doc) {
              data.push(doc);
            }
          };
          var mware = ('string' === typeof target)
                    ? middleware.fetchPath
                    : middleware.fetchQuery;
          mware(_req, _res, finish);
        }
      });

      middleware.fetchPath = createMiddleware();
      middleware.fetchPath.add(function (req, res, next) {
        req.context.guardReadPath(req, res, next);
      });
      middleware.fetchPath.add(function (req, res, next) {
        var path = req.target;
        // TODO We need to pass back array of document ids to assign to
        //      queries.someid.resultIds
        store._fetchPathData(path, {
          each: function (path, datum, ver) {
            res.send([path, datum, ver]);
          }
        , done: next
        });
      });

      middleware.fetchQuery = createMiddleware();
      middleware.fetchQuery.add(function (req, res, next) {
        req.context.guardQuery(req, res, next);
      });
      middleware.fetchQuery.add(function (req, res, next) {
        var query = req.target;
        store._fetchAndCompileQueryData(query, {
          each: function (path, datum, ver) {
            res.send([path, datum, ver]);
          }
        , done: next
        });
      });
    }
  , socket: function (store, socket, clientId) {
      socket.on('fetch', function (targets, contextName, cb) {
        var req = {
          targets: targets
        , clientId: socket.clientId
        , session: socket.session
        , context: store.context(contextName)
        };
        var res = {
          fail: cb
        , send: function (data) {
            // For OT
            // Note that `data` may be mutated by ot or other plugins
            store.emit('fetch', data, clientId, targets);

            cb(null, data);
          }
        };
        store.middleware.fetch(req, res);
      });

      socket.on('fetch:snapshot', function (ver, clientStartId, subs) {
        store._onSnapshotRequest(ver, clientStartId, clientId, socket, subs);
      });
    }
  }

, proto: {
    query: function (ns) {
      return this._queryMotifRegistry.queryTupleBuilder(ns);
    }

  , fetch: function () {
      var arglen = arguments.length
        , lastArg = arguments[arglen-1]
        , callback = (typeof lastArg === 'function') ? lastArg : noop
        , targets = Array.prototype.slice.call(arguments, 0, callback ? arglen-1 : arglen)
        , self = this
        ;

      compileTargets(targets, {
        done: function (targets) { /* this === model */
          // TODO Re-factor: similar to what's in Model#_waitOrFetchData
          var req = {
            targets: targets
          , clientId: self._clientId
          , context: self.context(self.scopedContext)
          };
          var res = {
            fail: callback
          , send: function (data) {
              data = data.data;
              if (data.length === 0) {
                callback(null);
              } else if (data.length === 1) {
                // TODO For find, we must pass the callback an Array
                var datum = data[0]
                var path = datum[0]
                  , value = datum[1]
                  , ver = datum[2];
                callback(null, value);
              } else {
                throw new Error('Unimplemented');
              }
            }
          };
          self.middleware.fetch(req, res);
        }
      });
    }

    // TODO Store#fetch

    /**
     * Fetches data associated with a queryTuple [ns, {queryMotif: queryArgs, ...}].
     *
     * @param {Array} queryTuple represented as
     * [ns, {queryMotif: queryArgs, ...}]
     * @param {Object} opts can have keys:
     *
     * - each: Function invoked for every matching document
     * - finish: Function invoked after the query results are fetched
     *   and after opts.each has been called on every matching document.
     * @api private
     */
  , _fetchAndCompileQueryData: function (queryTuple, opts) {
      var eachDatumCb = opts.each
        , finish = opts.done
        , queryJson = this._queryMotifRegistry.queryJSON(queryTuple)
        , queryId = queryTuple[queryTuple.length-1];
      this._fetchQueryData(queryTuple, function (err, result, version) {
        if (err) return finish(err);
        var path;
        if (Array.isArray(result)) {
          var resultIds = [];
          for (var i = 0, l = result.length; i < l; i++) {
            var doc = result[i];
            path = queryJson.from + '.' + doc.id;
            eachDatumCb(path, doc, version);
            resultIds.push(doc.id);
          }
        } else if (result) {
          path = queryJson.from + '.' + result.id;
          eachDatumCb(path, result, version);
        }
        finish(null);
      });
    }

    /**
     * @param {Array} queryTuple represented as [ns, queryMotif, params...]
     * @param {Function} callback(err, result, version)
     */
  , _fetchQueryData: function (queryTuple, callback) {
      var queryJson = this._queryMotifRegistry.queryJSON(queryTuple)
        , queryId = queryTuple[queryTuple.length-1];
      // TODO fetch(queryTuple, ...) ?
      this._queryCoordinator.fetch(queryJson, callback);
    }

    /**
     * Fetches data associated with a path in our data tree.
     *
     * @param {String} path to data that we want to fetch
     * @param {Object} opts can have keys:
     *
     * - each: Function invoked for every matching document
     * - finish: Function invoked after the query results are fetched
     *   and after opts.each has been called on every matching document.
     * @api private
     */
  , _fetchPathData: function (path, opts) {
      var eachDatumCb = opts.each
        , finish = opts.done
        , parts = splitPath(path)
        , root = parts[0]
        , remainder = parts[1];
      this.get(root, function (err, datum, ver) {
        if (err) return finish(err);
        if (typeof remainder === 'undefined') {
          eachDatumCb(path, datum, ver);
        } else {
          // The path looks like <root>.*.<remainder>
          // so set each property one level down
          patternMatchingDatum(root, remainder, datum, function (fullPath, datum) {
            eachDatumCb(fullPath, datum, ver);
          });
        }
        return finish(null);
      });
    }

    /**
     * @param {Number} ver is the version
     * @param {} clientStartId
     * @param {String} clientId
     * @param {Socket} socket
     * @param {Array} subs
     * @param {Boolean} shouldSubscribe
     * @api private
     */
  , _onSnapshotRequest: function (ver, clientStartId, clientId, socket, subs, shouldSubscribe) {
      var req = {
        startId: clientStartId
      , clientId: clientId
      , shouldSubscribe: shouldSubscribe
      , subs: subs
      , ver: ver
        // TODO Pass in proper context
      , context: this.context(this.scopedContext)
      };
      var res = {
        fail: function (err) {
          // TODO Should allow different kind of errors - e.g., "txnErr"
          socket.emit('fatalErr', err);
        }
      , send: function (channel, dataOrTxns, num) {
          socket.emit(channel, dataOrTxns, num);
        }
      };
      this.middleware.snapshot(req, res);
    }
  }
};

/**
 * @param {String} prefix is the part of the path up to ".*."
 * @param {String} remainder is the part of the path after ".*."
 * @param {Object} subDoc is the lookup value of the prefix
 * @param {Function} eachDatumCb is the callback for each datum matching the pattern
 * @api private
 */
function patternMatchingDatum (prefix, remainder, subDoc, eachDatumCb) {
  var parts          = splitPath(remainder)
    , appendToPrefix = parts[0]
    , remainder      = parts[1];
  for (var property in subDoc) {
    var value = subDoc[property];
    if (value.constructor !== Object && ! Array.isArray(value)) {
      // We can't lookup `appendToPrefix` on `value` in this case
      continue;
    }
    var newPrefix = prefix + '.' + property + '.' + appendToPrefix
      , newValue = lookup(appendToPrefix, value);
    if (typeof remainder === 'undefined') {
      eachDatumCb(newPrefix, newValue);
    } else {
      patternMatchingDatum(newPrefix, remainder, newValue, eachDatumCb);
    }
  }
}
